@compiler >= 6

include "Option.aes"
include "String.aes"

/// @title - Fungible token basic
contract FungibleToken =

  // This defines the state of type record encapsulating the contract's mutable state
  record state =
    { owner        : address      // the smart contract's owner address
    , total_supply : int          // total token supply
    , balances     : balances     // balances for each account
    , meta_info    : meta_info
    , minted : bool }  // token meta info (name, symbol, decimals)

  // This is the meta-information record type
  record meta_info =
    { name     : string
    , symbol   : string
    , decimals : int }

  // This is a type alias for the balances map
  type balances = map(address, int)

  // Declaration and structure of datatype event
  // and events that will be emitted on changes
  datatype event = Transfer(address, address, int)


  stateful entrypoint mint_coin(name: string, decimals : int, symbol : string, initial_owner_balance : option(int)) =
    require(state.minted == false, "The token is already minted")
    // If the name lenght is less than 1 symbol abort the execution
    require(String.length(name) >= 1, "STRING_TOO_SHORT_NAME")
    // If the symbol length is less than 1 symbol abort the execution
    require(String.length(symbol) >= 1, "STRING_TOO_SHORT_SYMBOL")
    // If the provided value for decimals is negative abort the execution
    require_non_negative_value(decimals)
    // If negative initial owner balance is passed, abort the execution
    let initial_supply = Option.default(0, initial_owner_balance)
    require_non_negative_value(initial_supply)

    let owner = Call.caller
    put(state{ owner = owner,
      total_supply = initial_supply,
      balances     = Option.match({}, (balance) => { [owner] = balance }, initial_owner_balance),
      meta_info    = { name = name, symbol = symbol, decimals = decimals },
      minted = true })
  // Create a fungible token with
  // the following name symbol and decimals
  // and set the inital smart contract state

  // For some reason Init don't initialize with mint values, But contract interface do so using seperate function to mint tokens...
  entrypoint init() =
    { owner        = Contract.address,
      total_supply = 0,
      balances     = {},
      meta_info    = { name = "", symbol = "", decimals = 0 },
      minted = false }

  // Get the token meta info
  entrypoint meta_info() : meta_info =
    state.meta_info

  // Get the token total supply
  entrypoint total_supply() : int =
    state.total_supply

  // Get the token owner address
  entrypoint owner() : address =
    state.owner

  // Get the balances state
  entrypoint balances() : balances =
    state.balances

  // Get balance for address of owner
  // returns option(int)
  // If the owner address haven't had any token balance
  // in this smart contract the return value is None
  // Otherwise Some(int) is returned with the current balance
  entrypoint balance(account: address) : option(int) =
    Map.lookup(account, state.balances)


  function require_non_negative_value(value : int) =
    require(value >= 0, "NON_NEGATIVE_VALUE_REQUIRED")

  function require_balance(account : address, value : int) =
    switch(balance(account))
      Some(balance) =>
        require(balance >= value, "ACCOUNT_INSUFFICIENT_BALANCE")
      None => abort("BALANCE_ACCOUNT_NOT_EXISTENT")

  stateful entrypoint internal_transfer(from_account: address, to_account: address, value: int) =
    require_non_negative_value(value)
    require_balance(from_account, value)
    put(state{ balances[from_account] @ b = b - value })
    put(state{ balances[to_account = 0] @ b = b + value })
    Chain.event(Transfer(from_account, to_account, value)) 


@compiler >= 6

include "String.aes"

contract CryptoHamster =

    record state = {
        index : int, 
        map_hamsters : map(string, hamster), 
        testvalue: int}

    record hamster = {
        id : int,
        name : string,
        dna : int}

    stateful entrypoint init() = 
        { index = 1,
            map_hamsters = {},
            testvalue = 42}
    
    public entrypoint read_test_value() : int =
        state.testvalue
    
    public entrypoint return_caller() : address =
        Call.caller

    public entrypoint cause_error() : unit =
        require(2 == 1, "require failed") 

    public stateful entrypoint add_test_value(one: int, two: int) : int =
        put(state{testvalue = one + two})
        one + two
    
    public entrypoint locally_add_two(one: int, two: int) : int =
        one + two
    
    public stateful entrypoint statefully_add_two(one: int, two: int) : int=
        put(state{testvalue = one + two})
        state.testvalue
    
    stateful entrypoint create_hamster(hamster_name: string) =
        require(!name_exists(hamster_name), "Name is already taken")
        let dna : int = generate_random_dna(hamster_name)
        create_hamster_by_name_dna(hamster_name, dna)

    entrypoint name_exists(name: string) : bool =
        Map.member(name, state.map_hamsters)

    entrypoint get_hamster_dna(name: string, test: option(int)) : int =
        require(name_exists(name), "There is no hamster with that name!")

        let needed_hamster : hamster = state.map_hamsters[name]

        needed_hamster.dna

    private stateful function create_hamster_by_name_dna(name: string, dna: int) =
        let new_hamster : hamster = {
            id = state.index,
            name = name,
            dna = dna}

        put(state{map_hamsters[name] = new_hamster})
        put(state{index = (state.index + 1)})

    private function generate_random_dna(name: string) : int =
        get_block_hash_bytes_as_int() - Chain.timestamp + state.index

    private function get_block_hash_bytes_as_int() : int =
        switch(Chain.block_hash(Chain.block_height - 1))
            None => abort("blockhash not found")
            Some(bytes) => Bytes.to_int(bytes)

    entrypoint test(name: string) : hash =
        String.sha3(name)
"

Example Output 3 : "
contract FundMe =

  record spend_args = { recipient : address,
                        amount    : int }

  record state = { contributions : map(address, int),
                   total         : int,
                   beneficiary   : address,
                   deadline      : int,
                   goal          : int }

  stateful function spend(args : spend_args) =
    Chain.spend(args.recipient, args.amount)

  entrypoint init(beneficiary, deadline, goal) : state =
    { contributions = {},
      beneficiary   = beneficiary,
      deadline      = deadline,
      total         = 0,
      goal          = goal }

  function is_contributor(addr) =
    Map.member(addr, state.contributions)

  stateful entrypoint contribute() =
    if(Chain.block_height >= state.deadline)
      spend({ recipient = Call.caller, amount = Call.value }) // Refund money
      false
    else
      let amount =
        switch(Map.lookup(Call.caller, state.contributions))
          None    => Call.value
          Some(n) => n + Call.value
      put(state{ contributions[Call.caller] = amount,
                 total @ tot = tot + Call.value })
      true

  stateful entrypoint withdraw() =
    if(Chain.block_height < state.deadline)
      abort("Cannot withdraw before deadline")
    if(Call.caller == state.beneficiary)
      withdraw_beneficiary()
    elif(is_contributor(Call.caller))
      withdraw_contributor()
    else
      abort("Not a contributor or beneficiary")

  stateful function withdraw_beneficiary() =
    require(state.total >= state.goal, "Project was not funded")
    spend({recipient = state.beneficiary,
           amount    = Contract.balance })

  stateful function withdraw_contributor() =
    if(state.total >= state.goal)
      abort("Project was funded")
    let to = Call.caller
    spend({recipient = to,
           amount    = state.contributions[to]})
    put(state{ contributions @ c = Map.delete(to, c) })




@compiler >= 6

include "Option.aes"
include "./core/IAEX141.aes"

contract SimpleNFTMarketplaceAE =

    datatype sale_status = OPEN | EXECUTED | CANCELLED

    datatype event
        = AnnounceSale(address, int) // seller, sale_id
        | CancelSale(int) // sale_id
        | ExecuteSale(address, address, int) // seller, buyer, sale_id

    record sale =
        { seller: address
        , token_id: int
        , price: int
        , status: sale_status }

    record state =
        { saleid_to_contract: map(int, IAEX141)
        , saleid_to_sale: map(int, sale)
        , sale_counter: int }

    stateful entrypoint init() =
        { saleid_to_contract = {},
          saleid_to_sale = {},
          sale_counter = 1 }

    stateful entrypoint announce_sale(nft_contract: IAEX141, token_id: int, price: int) : int =
        nft_contract.transfer_to_contract(token_id)
        let sale_id = state.sale_counter
        put(state{ saleid_to_contract[state.sale_counter] = nft_contract
            , saleid_to_sale[state.sale_counter] =
                { seller = Call.caller
                , token_id = token_id
                , price = price
                , status = OPEN }
            , sale_counter = sale_id + 1 })
        Chain.event(AnnounceSale(Call.caller, sale_id))
        sale_id

    payable stateful entrypoint execute_sale(sale_id: int) =
        let nft_contract = Option.force_msg(
                                Map.lookup(sale_id,
                                    state.saleid_to_contract), "UNKNOWN_TOKEN_CONTRACT")
        let sale = Option.force_msg(
                        Map.lookup(sale_id,
                            state.saleid_to_sale), "SALE_ID_NOT_EXISTS")
        require(sale.status == OPEN, "SALE_NOT_IN_STATUS_OPEN")
        require(Call.value == sale.price, "PROVIDED_AMOUNT_NOT_MATCHES_PRICE")
        Chain.spend(sale.seller, Call.value)
        nft_contract.transfer(Call.caller, sale.token_id, None)
        put(state{ saleid_to_sale[sale_id] = sale{ status = EXECUTED } })
        Chain.event(ExecuteSale(sale.seller, Call.caller, sale_id))

    stateful entrypoint cancel_sale(sale_id: int) =
        let nft_contract = Option.force_msg(
                                Map.lookup(sale_id,
                                    state.saleid_to_contract), "UNKNOWN_TOKEN_CONTRACT")
        let sale = Option.force_msg(
                        Map.lookup(sale_id,
                            state.saleid_to_sale), "SALE_ID_NOT_EXISTS")
        require(Call.caller == sale.seller, "SALE_CAN_ONLY_BE_CANCELLED_BY_SELLER")
        put(state{ saleid_to_sale[sale_id] = sale{ status = CANCELLED } })
        nft_contract.transfer(Call.caller, sale.token_id, None)
        Chain.event(CancelSale(sale_id))

    entrypoint get_sale(sale_id: int) : (IAEX141 * sale) =
        let nft_contract = Option.force_msg(
                                Map.lookup(sale_id,
                                    state.saleid_to_contract), "UNKNOWN_TOKEN_CONTRACT")
        let sale = Option.force_msg(
                        Map.lookup(sale_id,
                            state.saleid_to_sale), "SALE_ID_NOT_EXISTS")
        (nft_contract, sale)





@compiler >= 6

include "List.aes"
include "Option.aes"
include "Set.aes"
include "String.aes"
include "./core/utils.aes"
include "./core/IAEX141NFTReceiver.aes"

contract CollectionUniqueNFTs =

    datatype event
        = Mint(address, int) // to, token_id
        | Transfer(address, address, int) // from, to, token_id
        | Approval(address, address, int, string) // owner, approved_account, token_id, enabled ("true"/"false")
        | ApprovalForAll(address, address, string) // owner, operator, approved ("true"/"false")

    datatype metadata_type = URL | OBJECT_ID | MAP
    datatype metadata = MetadataIdentifier(string) | MetadataMap(map(string, string))

    record meta_info =
        { name: string
        , symbol: string
        , base_url: option(string)
        , metadata_type : metadata_type }
    
    record state =
        { owner: address
        , meta_info: meta_info
        , token_to_owners: map(int, address)
        , owners_to_tokens: map(address, Set.set(int))
        , balances: map(address, int)
        , approvals: map(int, address)
        , operators: map(address, map(address, bool))
        , metadata: map(int, metadata)
        , total_supply: int
        , counter: int }

    stateful entrypoint init(name: string, symbol: string) =
        require(String.length(name) >= 1, "STRING_TOO_SHORT_NAME")
        require(String.length(symbol) >= 1, "STRING_TOO_SHORT_SYMBOL")
        { owner = Contract.creator,
          meta_info = { name = name, symbol = symbol, base_url = None, metadata_type = MAP },
          token_to_owners = {},
          owners_to_tokens = {},
          balances = {},
          approvals = {},
          operators = {},
          metadata = {},
          total_supply = 0,
          counter = 1 }
    
    stateful entrypoint mint(to: address, metadata: option(metadata), data: option(string)) : int =  
        require_contract_owner()
        switch(metadata)
            None => abort("NO_METADATA_PROVIDED")
            Some(MetadataIdentifier(_)) => abort("NOT_METADATA_MAP")
            Some(v) =>
                let token_id = state.counter
                put(state{ counter = state.counter + 1
                    , total_supply = state.total_supply + 1
                    , balances[to = 0] @balance = balance + 1
                    , token_to_owners[token_id] = to
                    , owners_to_tokens[to = Set.new()] @owners_tokens = Set.insert(token_id, owners_tokens)
                    , metadata[token_id] = v })
                switch(invoke_nft_receiver(None, to, token_id, data))
                    (true, false) => abort("SAFE_TRANSFER_FAILED")
                    _ => Chain.event(Mint(to, token_id))
                token_id

    entrypoint aex141_extensions() : list(string) =
        ["mintable"]

    entrypoint meta_info() : meta_info =
        state.meta_info

    entrypoint metadata(token_id: int) : option(metadata) =
        Map.lookup(token_id, state.metadata)

    entrypoint total_supply() : int =
        state.total_supply

    entrypoint balance(owner: address) : option(int) =
        Map.lookup(owner, state.balances)

    entrypoint owner(token_id: int) : option(address) =
        Map.lookup(token_id, state.token_to_owners)

    stateful entrypoint transfer(to: address, token_id: int, data: option(string)) =
        let from = require_authorized(token_id)
        require(from != to, "SENDER_MUST_NOT_BE_RECEIVER")
        remove_approval(token_id)
        put(state{ balances[from] @balance1 = balance1 - 1
            , balances[to = 0] @balance2 = balance2 + 1
            , token_to_owners[token_id] = to
            , owners_to_tokens[from] @from_tokens = Set.delete(token_id, from_tokens)
            , owners_to_tokens[to = Set.new()] @to_tokens = Set.insert(token_id, to_tokens) })
        switch(invoke_nft_receiver(Some(from), to, token_id, data))
            (true, false) => abort("SAFE_TRANSFER_FAILED")
            _ => Chain.event(Transfer(from, to, token_id))

    stateful entrypoint transfer_to_contract(token_id: int) =
        let to = Call.caller
        require(Address.is_contract(to), "CALLER_MUST_BE_A_CONTRACT")
        let from = require_authorized(token_id)
        require(from != to, "SENDER_MUST_NOT_BE_RECEIVER")
        remove_approval(token_id)
        put(state{ balances[from] @balance1 = balance1 - 1
            , balances[to = 0] @balance2 = balance2 + 1
            , token_to_owners[token_id] = to
            , owners_to_tokens[from] @from_tokens = Set.delete(token_id, from_tokens)
            , owners_to_tokens[to = Set.new()] @to_tokens = Set.insert(token_id, to_tokens) })
        Chain.event(Transfer(from, to, token_id))

    stateful entrypoint approve(approved: address, token_id: int, enabled: bool) =
        require_authorized(token_id)
        if(enabled)
            put(state{approvals[token_id] = approved})
        else
            remove_approval(token_id)
        Chain.event(Approval(Call.caller, approved, token_id, Utils.bool_to_string(enabled)))

    stateful entrypoint approve_all(operator: address, enabled: bool) =
        put(state{operators @ ops = ops{[Call.caller = {}] @ op = op{[operator] = enabled}}})
        Chain.event(ApprovalForAll(Call.caller, operator, Utils.bool_to_string(enabled)))

    entrypoint get_approved(token_id: int) : option(address) =
        Map.lookup(token_id, state.approvals)

    entrypoint is_approved(token_id: int, a: address) : bool =
        switch(Map.lookup(token_id, state.approvals))
            None => false
            Some(o) => o == a

    entrypoint is_approved_for_all(owner: address, operator: address) : bool =
        switch(Map.lookup(owner, state.operators))
            None => false
            Some(ops) =>
                switch(Map.lookup(operator, ops))
                    None => false
                    Some(v) => v

    // internal helper functions

    function require_contract_owner() =
        require(Call.caller == state.owner, "ONLY_CONTRACT_OWNER_CALL_ALLOWED")

    function require_authorized(token_id: int) : address =
        let owner = switch(owner(token_id))
            None => abort("TOKEN_NOT_EXISTS")
            Some(v) => v
        require(Call.caller == owner || is_approved(token_id, Call.caller) || is_approved_for_all(owner, Call.caller), "ONLY_OWNER_APPROVED_OR_OPERATOR_CALL_ALLOWED")
        owner

    function is_token_owner(token_id: int, a: address) : bool =
        switch(Map.lookup(token_id, state.token_to_owners))
            None => false
            Some(o) => o == a

    stateful function remove_approval(token_id: int) =
        if(Map.member(token_id, state.approvals))
            put(state{ approvals = Map.delete(token_id, state.approvals) })

    function invoke_nft_receiver(from: option(address), to: address, token_id: int, data: option(string)) : (bool * bool) =
        if(Address.is_contract(to))
            let c = Address.to_contract(to)
            switch(c.on_aex141_received(from, token_id, data, protected = true) : option(bool))
                None => (true, false)
                Some(val) => (true, val)
        else
            (false, false)



